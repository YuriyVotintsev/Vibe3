<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match-3 Game - Phaser</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <script>
        // Build ID - updated on each commit
        const BUILD_ID = '250106-001';

        // Game constants
        const BOARD_SIZE = 8;
        const CELL_SIZE = 64;
        const GAP = 4;
        const BOARD_OFFSET_X = 50;
        const BOARD_OFFSET_Y = 120;
        const FALL_SPEED = 500; // pixels per second
        const SWAP_DURATION = 150;
        const SPAWN_DELAY = 80; // ms between spawning new gems

        const GEM_COLORS = [
            0xe74c3c, // red
            0x3498db, // blue
            0x27ae60, // green
            0xf1c40f, // yellow
            0x9b59b6, // purple
            0xe67e22  // orange
        ];

        // Gem states
        const GEM_STATE = {
            IDLE: 'idle',
            FALLING: 'falling',
            SWAPPING: 'swapping',
            MATCHED: 'matched'
        };

        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
            }

            init() {
                this.board = [];           // Logical board [row][col] = gemType
                this.gems = [];            // Sprite references [row][col] = sprite
                this.selectedGem = null;
                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.lastSpawnTime = {};   // Track last spawn time per column
                this.pendingMatches = [];  // Gems waiting to be checked after landing
            }

            preload() {
                this.createGemTextures();
            }

            createGemTextures() {
                const size = CELL_SIZE - 8;
                const radius = 10;

                for (let i = 0; i < GEM_COLORS.length; i++) {
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                    graphics.fillStyle(GEM_COLORS[i], 1);
                    graphics.fillRoundedRect(0, 0, size, size, radius);
                    graphics.fillStyle(0xffffff, 0.3);
                    graphics.fillRoundedRect(4, 4, size - 20, size - 20, radius - 2);
                    graphics.fillStyle(0x000000, 0.2);
                    graphics.fillRoundedRect(8, size - 16, size - 16, 8, 4);
                    graphics.generateTexture(`gem_${i}`, size, size);
                    graphics.destroy();
                }

                const selectGraphics = this.make.graphics({ x: 0, y: 0, add: false });
                selectGraphics.lineStyle(4, 0xffffff, 1);
                selectGraphics.strokeRoundedRect(2, 2, CELL_SIZE - 4, CELL_SIZE - 4, 12);
                selectGraphics.generateTexture('selection', CELL_SIZE, CELL_SIZE);
                selectGraphics.destroy();
            }

            create() {
                // Background
                this.add.rectangle(
                    this.cameras.main.width / 2,
                    this.cameras.main.height / 2,
                    this.cameras.main.width,
                    this.cameras.main.height,
                    0x1a1a2e
                );

                // Board background
                const boardWidth = BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 20;
                const boardHeight = BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 20;
                this.add.rectangle(
                    BOARD_OFFSET_X + boardWidth / 2 - 10,
                    BOARD_OFFSET_Y + boardHeight / 2 - 10,
                    boardWidth,
                    boardHeight,
                    0x000000,
                    0.3
                ).setStrokeStyle(2, 0x333333);

                this.createUI();
                this.createBoard();

                this.selectionIndicator = this.add.image(0, 0, 'selection');
                this.selectionIndicator.setVisible(false);
                this.selectionIndicator.setDepth(100);

                this.removeInitialMatches();

                this.input.on('gameobjectdown', this.onGemClick, this);

                // Initialize spawn timers
                for (let col = 0; col < BOARD_SIZE; col++) {
                    this.lastSpawnTime[col] = 0;
                }
            }

            createUI() {
                this.add.text(
                    this.cameras.main.width / 2, 30,
                    'üéÆ Match-3',
                    { fontSize: '32px', fontFamily: 'Segoe UI', color: '#e94560' }
                ).setOrigin(0.5);

                const panelY = 75;
                const panelSpacing = 150;
                const startX = this.cameras.main.width / 2 - panelSpacing;

                this.add.text(startX, panelY, '–û–ß–ö–ò', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.scoreText = this.add.text(startX, panelY + 22, '0', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                this.add.text(startX + panelSpacing, panelY, '–•–û–î–´', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.movesText = this.add.text(startX + panelSpacing, panelY + 22, '0', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                this.add.text(startX + panelSpacing * 2, panelY, '–ö–û–ú–ë–û', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.comboText = this.add.text(startX + panelSpacing * 2, panelY + 22, 'x1', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                this.messageText = this.add.text(
                    this.cameras.main.width / 2,
                    BOARD_OFFSET_Y + BOARD_SIZE * (CELL_SIZE + GAP) + 30,
                    '',
                    { fontSize: '20px', color: '#55efc4' }
                ).setOrigin(0.5);

                const btnY = BOARD_OFFSET_Y + BOARD_SIZE * (CELL_SIZE + GAP) + 70;
                const btn = this.add.rectangle(this.cameras.main.width / 2, btnY, 160, 45, 0xe94560)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => btn.setFillStyle(0xc0392b))
                    .on('pointerout', () => btn.setFillStyle(0xe94560))
                    .on('pointerdown', () => this.restartGame());

                this.add.text(this.cameras.main.width / 2, btnY, 'üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞', { fontSize: '16px', color: '#ffffff' }).setOrigin(0.5);

                // Build ID display
                this.add.text(
                    this.cameras.main.width - 10,
                    this.cameras.main.height - 10,
                    `build: ${BUILD_ID}`,
                    { fontSize: '10px', color: '#666666' }
                ).setOrigin(1, 1);
            }

            createBoard() {
                this.board = [];
                this.gems = [];

                for (let row = 0; row < BOARD_SIZE; row++) {
                    this.board[row] = [];
                    this.gems[row] = [];
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const gemType = Phaser.Math.Between(0, GEM_COLORS.length - 1);
                        this.board[row][col] = gemType;
                        this.gems[row][col] = this.createGem(row, col, gemType);
                    }
                }
            }

            createGem(row, col, gemType, startY = null) {
                const pos = this.getGemPosition(row, col);
                const gem = this.add.image(pos.x, startY !== null ? startY : pos.y, `gem_${gemType}`);
                gem.setInteractive({ useHandCursor: true });
                gem.setData('row', row);
                gem.setData('col', col);
                gem.setData('type', gemType);
                gem.setData('state', GEM_STATE.IDLE);
                gem.setData('targetY', pos.y);
                return gem;
            }

            getGemPosition(row, col) {
                return {
                    x: BOARD_OFFSET_X + col * (CELL_SIZE + GAP) + CELL_SIZE / 2,
                    y: BOARD_OFFSET_Y + row * (CELL_SIZE + GAP) + CELL_SIZE / 2
                };
            }

            removeInitialMatches() {
                let hasMatches = true;
                while (hasMatches) {
                    const matches = this.findAllMatches();
                    if (matches.length === 0) {
                        hasMatches = false;
                    } else {
                        matches.forEach(({ row, col }) => {
                            const newType = Phaser.Math.Between(0, GEM_COLORS.length - 1);
                            this.board[row][col] = newType;
                            this.gems[row][col].setTexture(`gem_${newType}`);
                            this.gems[row][col].setData('type', newType);
                        });
                    }
                }
            }

            // Main game loop
            update(time, delta) {
                this.updateFallingGems(delta);
                this.updateGravity();
                this.spawnNewGems(time);
                this.checkLandedGems();
            }

            updateFallingGems(delta) {
                const fallAmount = (FALL_SPEED * delta) / 1000;

                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const gem = this.gems[row][col];
                        if (!gem) continue;

                        if (gem.getData('state') === GEM_STATE.FALLING) {
                            const targetY = gem.getData('targetY');

                            if (gem.y < targetY) {
                                gem.y = Math.min(gem.y + fallAmount, targetY);

                                if (gem.y >= targetY) {
                                    gem.y = targetY;
                                    gem.setData('state', GEM_STATE.IDLE);
                                    this.pendingMatches.push({ row, col });
                                }
                            }
                        }
                    }
                }
            }

            updateGravity() {
                // Check each column for gaps and make gems fall
                for (let col = 0; col < BOARD_SIZE; col++) {
                    for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                        if (this.board[row][col] === null) {
                            // Find gem above to fall
                            for (let aboveRow = row - 1; aboveRow >= 0; aboveRow--) {
                                if (this.board[aboveRow][col] !== null) {
                                    const gem = this.gems[aboveRow][col];
                                    if (gem && gem.getData('state') === GEM_STATE.IDLE) {
                                        // Move gem down
                                        this.board[row][col] = this.board[aboveRow][col];
                                        this.board[aboveRow][col] = null;

                                        this.gems[row][col] = gem;
                                        this.gems[aboveRow][col] = null;

                                        gem.setData('row', row);
                                        gem.setData('targetY', this.getGemPosition(row, col).y);
                                        gem.setData('state', GEM_STATE.FALLING);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            spawnNewGems(time) {
                // Spawn new gems one at a time per column with delay
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // Check if top row is empty and no gem is currently falling into it
                    if (this.board[0][col] === null) {
                        // Check if enough time has passed since last spawn in this column
                        if (time - this.lastSpawnTime[col] >= SPAWN_DELAY) {
                            // Check that no gem is falling through row 0
                            let canSpawn = true;
                            for (let r = 0; r < BOARD_SIZE; r++) {
                                const gem = this.gems[r][col];
                                if (gem && gem.getData('state') === GEM_STATE.FALLING) {
                                    const targetRow = gem.getData('row');
                                    if (targetRow <= 0) {
                                        canSpawn = false;
                                        break;
                                    }
                                }
                            }

                            if (canSpawn) {
                                const gemType = Phaser.Math.Between(0, GEM_COLORS.length - 1);
                                const startY = BOARD_OFFSET_Y - CELL_SIZE / 2 - GAP;
                                const gem = this.createGem(0, col, gemType, startY);

                                this.board[0][col] = gemType;
                                this.gems[0][col] = gem;
                                gem.setData('state', GEM_STATE.FALLING);

                                this.lastSpawnTime[col] = time;
                            }
                        }
                    }
                }
            }

            checkLandedGems() {
                if (this.pendingMatches.length === 0) return;

                // Process landed gems
                const toCheck = [...this.pendingMatches];
                this.pendingMatches = [];

                // Find matches
                const matches = this.findAllMatches();

                if (matches.length > 0) {
                    // Calculate score
                    const points = matches.length * 10 * this.combo;
                    this.score += points;
                    this.scoreText.setText(this.score.toString());

                    if (matches.length > 3) {
                        this.showMessage(`+${points}`);
                    }

                    // Destroy matched gems
                    matches.forEach(({ row, col }) => {
                        const gem = this.gems[row][col];
                        if (gem && gem.getData('state') !== GEM_STATE.MATCHED) {
                            gem.setData('state', GEM_STATE.MATCHED);

                            this.tweens.add({
                                targets: gem,
                                scale: 0,
                                alpha: 0,
                                duration: 150,
                                ease: 'Power2',
                                onComplete: () => {
                                    gem.destroy();
                                }
                            });

                            this.board[row][col] = null;
                            this.gems[row][col] = null;
                        }
                    });

                    this.combo++;
                    this.comboText.setText(`x${this.combo}`);
                }
            }

            onGemClick(pointer, gem) {
                // Can only click gems that are idle
                if (gem.getData('state') !== GEM_STATE.IDLE) return;

                const row = gem.getData('row');
                const col = gem.getData('col');

                if (this.selectedGem === null) {
                    this.selectedGem = { row, col, gem };
                    const pos = this.getGemPosition(row, col);
                    this.selectionIndicator.setPosition(pos.x, pos.y);
                    this.selectionIndicator.setVisible(true);

                    this.tweens.killTweensOf(this.selectionIndicator);
                    this.tweens.add({
                        targets: this.selectionIndicator,
                        scale: { from: 1, to: 1.1 },
                        duration: 300,
                        yoyo: true,
                        repeat: -1
                    });
                } else {
                    const { row: prevRow, col: prevCol, gem: prevGem } = this.selectedGem;

                    // Check if previous gem is still valid and idle
                    if (!prevGem || prevGem.getData('state') !== GEM_STATE.IDLE) {
                        this.clearSelection();
                        return;
                    }

                    if (this.areAdjacent(prevRow, prevCol, row, col)) {
                        this.clearSelection();
                        this.swapGems(prevRow, prevCol, row, col);
                    } else {
                        this.selectedGem = { row, col, gem };
                        const pos = this.getGemPosition(row, col);
                        this.selectionIndicator.setPosition(pos.x, pos.y);
                    }
                }
            }

            clearSelection() {
                this.selectedGem = null;
                this.selectionIndicator.setVisible(false);
                this.tweens.killTweensOf(this.selectionIndicator);
                this.selectionIndicator.setScale(1);
            }

            areAdjacent(row1, col1, row2, col2) {
                const rowDiff = Math.abs(row1 - row2);
                const colDiff = Math.abs(col1 - col2);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            swapGems(row1, col1, row2, col2) {
                const gem1 = this.gems[row1][col1];
                const gem2 = this.gems[row2][col2];

                if (!gem1 || !gem2) return;
                if (gem1.getData('state') !== GEM_STATE.IDLE) return;
                if (gem2.getData('state') !== GEM_STATE.IDLE) return;

                gem1.setData('state', GEM_STATE.SWAPPING);
                gem2.setData('state', GEM_STATE.SWAPPING);

                const pos1 = this.getGemPosition(row1, col1);
                const pos2 = this.getGemPosition(row2, col2);

                // Swap in data
                [this.board[row1][col1], this.board[row2][col2]] = [this.board[row2][col2], this.board[row1][col1]];
                [this.gems[row1][col1], this.gems[row2][col2]] = [this.gems[row2][col2], this.gems[row1][col1]];

                gem1.setData('row', row2);
                gem1.setData('col', col2);
                gem2.setData('row', row1);
                gem2.setData('col', col1);

                // Animate swap
                this.tweens.add({
                    targets: gem1,
                    x: pos2.x,
                    y: pos2.y,
                    duration: SWAP_DURATION,
                    ease: 'Power2'
                });

                this.tweens.add({
                    targets: gem2,
                    x: pos1.x,
                    y: pos1.y,
                    duration: SWAP_DURATION,
                    ease: 'Power2',
                    onComplete: () => {
                        // Set to IDLE first so findAllMatches can check them
                        gem1.setData('state', GEM_STATE.IDLE);
                        gem2.setData('state', GEM_STATE.IDLE);
                        gem1.setData('targetY', pos2.y);
                        gem2.setData('targetY', pos1.y);

                        // Check for matches
                        const matches = this.findAllMatches();

                        if (matches.length > 0) {
                            this.moves++;
                            this.movesText.setText(this.moves.toString());
                            this.combo = 1;

                            this.pendingMatches.push({ row: row2, col: col2 });
                            this.pendingMatches.push({ row: row1, col: col1 });
                        } else {
                            // Swap back
                            gem1.setData('state', GEM_STATE.SWAPPING);
                            gem2.setData('state', GEM_STATE.SWAPPING);

                            [this.board[row1][col1], this.board[row2][col2]] = [this.board[row2][col2], this.board[row1][col1]];
                            [this.gems[row1][col1], this.gems[row2][col2]] = [this.gems[row2][col2], this.gems[row1][col1]];

                            gem1.setData('row', row1);
                            gem1.setData('col', col1);
                            gem2.setData('row', row2);
                            gem2.setData('col', col2);

                            this.tweens.add({
                                targets: gem1,
                                x: pos1.x,
                                y: pos1.y,
                                duration: SWAP_DURATION,
                                ease: 'Power2'
                            });

                            this.tweens.add({
                                targets: gem2,
                                x: pos2.x,
                                y: pos2.y,
                                duration: SWAP_DURATION,
                                ease: 'Power2',
                                onComplete: () => {
                                    gem1.setData('state', GEM_STATE.IDLE);
                                    gem2.setData('state', GEM_STATE.IDLE);
                                    gem1.setData('targetY', pos1.y);
                                    gem2.setData('targetY', pos2.y);
                                }
                            });

                            this.showMessage('–ù–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π!');
                        }
                    }
                });
            }

            findAllMatches() {
                const matches = new Set();

                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE - 2; col++) {
                        const type = this.board[row][col];
                        if (type !== null &&
                            type === this.board[row][col + 1] &&
                            type === this.board[row][col + 2]) {
                            // Check all gems are idle
                            const g1 = this.gems[row][col];
                            const g2 = this.gems[row][col + 1];
                            const g3 = this.gems[row][col + 2];
                            if (g1?.getData('state') === GEM_STATE.IDLE &&
                                g2?.getData('state') === GEM_STATE.IDLE &&
                                g3?.getData('state') === GEM_STATE.IDLE) {
                                matches.add(`${row},${col}`);
                                matches.add(`${row},${col + 1}`);
                                matches.add(`${row},${col + 2}`);

                                let k = col + 3;
                                while (k < BOARD_SIZE && this.board[row][k] === type) {
                                    const gk = this.gems[row][k];
                                    if (gk?.getData('state') === GEM_STATE.IDLE) {
                                        matches.add(`${row},${k}`);
                                    }
                                    k++;
                                }
                            }
                        }
                    }
                }

                for (let col = 0; col < BOARD_SIZE; col++) {
                    for (let row = 0; row < BOARD_SIZE - 2; row++) {
                        const type = this.board[row][col];
                        if (type !== null &&
                            type === this.board[row + 1][col] &&
                            type === this.board[row + 2][col]) {
                            const g1 = this.gems[row][col];
                            const g2 = this.gems[row + 1][col];
                            const g3 = this.gems[row + 2][col];
                            if (g1?.getData('state') === GEM_STATE.IDLE &&
                                g2?.getData('state') === GEM_STATE.IDLE &&
                                g3?.getData('state') === GEM_STATE.IDLE) {
                                matches.add(`${row},${col}`);
                                matches.add(`${row + 1},${col}`);
                                matches.add(`${row + 2},${col}`);

                                let k = row + 3;
                                while (k < BOARD_SIZE && this.board[k][col] === type) {
                                    const gk = this.gems[k][col];
                                    if (gk?.getData('state') === GEM_STATE.IDLE) {
                                        matches.add(`${k},${col}`);
                                    }
                                    k++;
                                }
                            }
                        }
                    }
                }

                return Array.from(matches).map(pos => {
                    const [row, col] = pos.split(',').map(Number);
                    return { row, col };
                });
            }

            showMessage(text) {
                this.messageText.setText(text);
                this.messageText.setAlpha(1);

                this.tweens.add({
                    targets: this.messageText,
                    alpha: 0,
                    delay: 1000,
                    duration: 500
                });
            }

            restartGame() {
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (this.gems[row] && this.gems[row][col]) {
                            this.gems[row][col].destroy();
                        }
                    }
                }

                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.selectedGem = null;
                this.pendingMatches = [];

                this.scoreText.setText('0');
                this.movesText.setText('0');
                this.comboText.setText('x1');

                this.clearSelection();

                for (let col = 0; col < BOARD_SIZE; col++) {
                    this.lastSpawnTime[col] = 0;
                }

                this.createBoard();
                this.removeInitialMatches();

                this.showMessage('–ù–æ–≤–∞—è –∏–≥—Ä–∞!');
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 100,
            height: BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 220,
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scene: MainScene,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
