<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match-3 Game - Phaser</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <script>
        // Game constants
        const BOARD_SIZE = 8;
        const CELL_SIZE = 64;
        const GAP = 4;
        const BOARD_OFFSET_X = 50;
        const BOARD_OFFSET_Y = 120;
        const FALL_SPEED = 400; // pixels per second
        const SWAP_DURATION = 150;

        const GEM_COLORS = [
            0xe74c3c, // red
            0x3498db, // blue
            0x27ae60, // green
            0xf1c40f, // yellow
            0x9b59b6, // purple
            0xe67e22  // orange
        ];

        const GEM_SYMBOLS = ['üíé', 'üî∑', 'üíö', '‚≠ê', 'üîÆ', 'üî∂'];

        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
            }

            init() {
                this.board = [];           // Logical board [row][col] = gemType
                this.gems = [];            // Sprite references [row][col] = sprite
                this.selectedGem = null;
                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.isProcessing = false;
            }

            preload() {
                // Generate gem textures programmatically
                this.createGemTextures();
            }

            createGemTextures() {
                const size = CELL_SIZE - 8;
                const radius = 10;

                for (let i = 0; i < GEM_COLORS.length; i++) {
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

                    // Main gem body with gradient effect
                    graphics.fillStyle(GEM_COLORS[i], 1);
                    graphics.fillRoundedRect(0, 0, size, size, radius);

                    // Highlight
                    graphics.fillStyle(0xffffff, 0.3);
                    graphics.fillRoundedRect(4, 4, size - 20, size - 20, radius - 2);

                    // Shadow
                    graphics.fillStyle(0x000000, 0.2);
                    graphics.fillRoundedRect(8, size - 16, size - 16, 8, 4);

                    graphics.generateTexture(`gem_${i}`, size, size);
                    graphics.destroy();
                }

                // Selection highlight texture
                const selectGraphics = this.make.graphics({ x: 0, y: 0, add: false });
                selectGraphics.lineStyle(4, 0xffffff, 1);
                selectGraphics.strokeRoundedRect(2, 2, CELL_SIZE - 4, CELL_SIZE - 4, 12);
                selectGraphics.generateTexture('selection', CELL_SIZE, CELL_SIZE);
                selectGraphics.destroy();
            }

            create() {
                // Background
                this.add.rectangle(
                    this.cameras.main.width / 2,
                    this.cameras.main.height / 2,
                    this.cameras.main.width,
                    this.cameras.main.height,
                    0x1a1a2e
                );

                // Board background
                const boardWidth = BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 20;
                const boardHeight = BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 20;
                this.add.rectangle(
                    BOARD_OFFSET_X + boardWidth / 2 - 10,
                    BOARD_OFFSET_Y + boardHeight / 2 - 10,
                    boardWidth,
                    boardHeight,
                    0x000000,
                    0.3
                ).setStrokeStyle(2, 0x333333);

                // UI
                this.createUI();

                // Create board
                this.createBoard();

                // Selection indicator
                this.selectionIndicator = this.add.image(0, 0, 'selection');
                this.selectionIndicator.setVisible(false);
                this.selectionIndicator.setDepth(100);

                // Remove initial matches
                this.removeInitialMatches();

                // Input
                this.input.on('gameobjectdown', this.onGemClick, this);
            }

            createUI() {
                // Title
                this.add.text(
                    this.cameras.main.width / 2, 30,
                    'üéÆ Match-3',
                    { fontSize: '32px', fontFamily: 'Segoe UI', color: '#e94560' }
                ).setOrigin(0.5);

                // Score panel
                const panelY = 75;
                const panelSpacing = 150;
                const startX = this.cameras.main.width / 2 - panelSpacing;

                // Score
                this.add.text(startX, panelY, '–û–ß–ö–ò', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.scoreText = this.add.text(startX, panelY + 22, '0', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                // Moves
                this.add.text(startX + panelSpacing, panelY, '–•–û–î–´', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.movesText = this.add.text(startX + panelSpacing, panelY + 22, '0', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                // Combo
                this.add.text(startX + panelSpacing * 2, panelY, '–ö–û–ú–ë–û', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.comboText = this.add.text(startX + panelSpacing * 2, panelY + 22, 'x1', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                // Message
                this.messageText = this.add.text(
                    this.cameras.main.width / 2,
                    BOARD_OFFSET_Y + BOARD_SIZE * (CELL_SIZE + GAP) + 30,
                    '',
                    { fontSize: '20px', color: '#55efc4' }
                ).setOrigin(0.5);

                // Restart button
                const btnY = BOARD_OFFSET_Y + BOARD_SIZE * (CELL_SIZE + GAP) + 70;
                const btn = this.add.rectangle(this.cameras.main.width / 2, btnY, 160, 45, 0xe94560)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => btn.setFillStyle(0xc0392b))
                    .on('pointerout', () => btn.setFillStyle(0xe94560))
                    .on('pointerdown', () => this.restartGame());

                this.add.text(this.cameras.main.width / 2, btnY, 'üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞', { fontSize: '16px', color: '#ffffff' }).setOrigin(0.5);
            }

            createBoard() {
                this.board = [];
                this.gems = [];

                for (let row = 0; row < BOARD_SIZE; row++) {
                    this.board[row] = [];
                    this.gems[row] = [];
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const gemType = Phaser.Math.Between(0, GEM_COLORS.length - 1);
                        this.board[row][col] = gemType;
                        this.gems[row][col] = this.createGem(row, col, gemType);
                    }
                }
            }

            createGem(row, col, gemType, startY = null) {
                const pos = this.getGemPosition(row, col);
                const gem = this.add.image(pos.x, startY !== null ? startY : pos.y, `gem_${gemType}`);
                gem.setInteractive({ useHandCursor: true });
                gem.setData('row', row);
                gem.setData('col', col);
                gem.setData('type', gemType);
                return gem;
            }

            getGemPosition(row, col) {
                return {
                    x: BOARD_OFFSET_X + col * (CELL_SIZE + GAP) + CELL_SIZE / 2,
                    y: BOARD_OFFSET_Y + row * (CELL_SIZE + GAP) + CELL_SIZE / 2
                };
            }

            removeInitialMatches() {
                let hasMatches = true;
                while (hasMatches) {
                    const matches = this.findAllMatches();
                    if (matches.length === 0) {
                        hasMatches = false;
                    } else {
                        matches.forEach(({ row, col }) => {
                            const newType = Phaser.Math.Between(0, GEM_COLORS.length - 1);
                            this.board[row][col] = newType;
                            this.gems[row][col].setTexture(`gem_${newType}`);
                            this.gems[row][col].setData('type', newType);
                        });
                    }
                }
            }

            onGemClick(pointer, gem) {
                if (this.isProcessing) return;

                const row = gem.getData('row');
                const col = gem.getData('col');

                if (this.selectedGem === null) {
                    this.selectedGem = { row, col };
                    const pos = this.getGemPosition(row, col);
                    this.selectionIndicator.setPosition(pos.x, pos.y);
                    this.selectionIndicator.setVisible(true);

                    // Pulse animation
                    this.tweens.add({
                        targets: this.selectionIndicator,
                        scale: { from: 1, to: 1.1 },
                        duration: 300,
                        yoyo: true,
                        repeat: -1
                    });
                } else {
                    const { row: prevRow, col: prevCol } = this.selectedGem;

                    if (this.areAdjacent(prevRow, prevCol, row, col)) {
                        this.selectionIndicator.setVisible(false);
                        this.tweens.killTweensOf(this.selectionIndicator);
                        this.selectionIndicator.setScale(1);
                        this.swapGems(prevRow, prevCol, row, col);
                    } else {
                        this.selectedGem = { row, col };
                        const pos = this.getGemPosition(row, col);
                        this.selectionIndicator.setPosition(pos.x, pos.y);
                    }
                }
            }

            areAdjacent(row1, col1, row2, col2) {
                const rowDiff = Math.abs(row1 - row2);
                const colDiff = Math.abs(col1 - col2);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            async swapGems(row1, col1, row2, col2) {
                this.isProcessing = true;
                this.selectedGem = null;

                const gem1 = this.gems[row1][col1];
                const gem2 = this.gems[row2][col2];
                const pos1 = this.getGemPosition(row1, col1);
                const pos2 = this.getGemPosition(row2, col2);

                // Animate swap
                await this.animateSwap(gem1, gem2, pos1, pos2);

                // Swap in data
                [this.board[row1][col1], this.board[row2][col2]] = [this.board[row2][col2], this.board[row1][col1]];
                [this.gems[row1][col1], this.gems[row2][col2]] = [this.gems[row2][col2], this.gems[row1][col1]];

                gem1.setData('row', row2);
                gem1.setData('col', col2);
                gem2.setData('row', row1);
                gem2.setData('col', col1);

                // Check for matches
                const matches = this.findAllMatches();

                if (matches.length > 0) {
                    this.moves++;
                    this.movesText.setText(this.moves.toString());
                    this.combo = 1;
                    await this.processMatches();
                } else {
                    // Swap back
                    await this.animateSwap(gem1, gem2, pos2, pos1);

                    [this.board[row1][col1], this.board[row2][col2]] = [this.board[row2][col2], this.board[row1][col1]];
                    [this.gems[row1][col1], this.gems[row2][col2]] = [this.gems[row2][col2], this.gems[row1][col1]];

                    gem1.setData('row', row1);
                    gem1.setData('col', col1);
                    gem2.setData('row', row2);
                    gem2.setData('col', col2);

                    this.showMessage('–ù–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π!');
                }

                this.isProcessing = false;
            }

            animateSwap(gem1, gem2, pos1, pos2) {
                return new Promise(resolve => {
                    this.tweens.add({
                        targets: gem1,
                        x: pos2.x,
                        y: pos2.y,
                        duration: SWAP_DURATION,
                        ease: 'Power2'
                    });
                    this.tweens.add({
                        targets: gem2,
                        x: pos1.x,
                        y: pos1.y,
                        duration: SWAP_DURATION,
                        ease: 'Power2',
                        onComplete: resolve
                    });
                });
            }

            findAllMatches() {
                const matches = new Set();

                // Horizontal
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE - 2; col++) {
                        const type = this.board[row][col];
                        if (type !== null &&
                            type === this.board[row][col + 1] &&
                            type === this.board[row][col + 2]) {
                            matches.add(`${row},${col}`);
                            matches.add(`${row},${col + 1}`);
                            matches.add(`${row},${col + 2}`);

                            let k = col + 3;
                            while (k < BOARD_SIZE && this.board[row][k] === type) {
                                matches.add(`${row},${k}`);
                                k++;
                            }
                        }
                    }
                }

                // Vertical
                for (let col = 0; col < BOARD_SIZE; col++) {
                    for (let row = 0; row < BOARD_SIZE - 2; row++) {
                        const type = this.board[row][col];
                        if (type !== null &&
                            type === this.board[row + 1][col] &&
                            type === this.board[row + 2][col]) {
                            matches.add(`${row},${col}`);
                            matches.add(`${row + 1},${col}`);
                            matches.add(`${row + 2},${col}`);

                            let k = row + 3;
                            while (k < BOARD_SIZE && this.board[k][col] === type) {
                                matches.add(`${k},${col}`);
                                k++;
                            }
                        }
                    }
                }

                return Array.from(matches).map(pos => {
                    const [row, col] = pos.split(',').map(Number);
                    return { row, col };
                });
            }

            async processMatches() {
                let matches = this.findAllMatches();

                while (matches.length > 0) {
                    // Calculate score
                    const points = matches.length * 10 * this.combo;
                    this.score += points;
                    this.scoreText.setText(this.score.toString());

                    if (matches.length > 3) {
                        this.showMessage(`–û—Ç–ª–∏—á–Ω–æ! +${points}`);
                    }

                    // Animate destruction
                    await this.animateDestruction(matches);

                    // Remove from board
                    matches.forEach(({ row, col }) => {
                        this.board[row][col] = null;
                    });

                    // Drop and fill
                    await this.dropAndFill();

                    // Update combo
                    this.combo++;
                    this.comboText.setText(`x${this.combo}`);

                    // Check for new matches
                    matches = this.findAllMatches();

                    if (matches.length > 0) {
                        this.showMessage(`–ö–æ–º–±–æ x${this.combo}!`);
                    }
                }
            }

            animateDestruction(matches) {
                return new Promise(resolve => {
                    let completed = 0;
                    const total = matches.length;

                    matches.forEach(({ row, col }) => {
                        const gem = this.gems[row][col];
                        this.tweens.add({
                            targets: gem,
                            scale: 0,
                            alpha: 0,
                            duration: 200,
                            ease: 'Power2',
                            onComplete: () => {
                                gem.destroy();
                                this.gems[row][col] = null;
                                completed++;
                                if (completed === total) resolve();
                            }
                        });
                    });
                });
            }

            async dropAndFill() {
                const animations = [];
                let maxDistance = 0;

                // Process each column
                for (let col = 0; col < BOARD_SIZE; col++) {
                    let emptySpaces = 0;

                    // Drop existing gems
                    for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                        if (this.board[row][col] === null) {
                            emptySpaces++;
                        } else if (emptySpaces > 0) {
                            const newRow = row + emptySpaces;
                            const gem = this.gems[row][col];
                            const targetPos = this.getGemPosition(newRow, col);
                            const distance = emptySpaces;

                            // Update data
                            this.board[newRow][col] = this.board[row][col];
                            this.board[row][col] = null;
                            this.gems[newRow][col] = gem;
                            this.gems[row][col] = null;

                            gem.setData('row', newRow);

                            const duration = (distance * (CELL_SIZE + GAP)) / FALL_SPEED * 1000;
                            maxDistance = Math.max(maxDistance, distance);

                            animations.push(new Promise(resolve => {
                                this.tweens.add({
                                    targets: gem,
                                    y: targetPos.y,
                                    duration: duration,
                                    ease: 'Linear',
                                    onComplete: resolve
                                });
                            }));
                        }
                    }

                    // Create new gems
                    for (let i = 0; i < emptySpaces; i++) {
                        const row = emptySpaces - 1 - i;
                        const gemType = Phaser.Math.Between(0, GEM_COLORS.length - 1);
                        const startOffset = emptySpaces - row;
                        const startY = BOARD_OFFSET_Y - startOffset * (CELL_SIZE + GAP) - CELL_SIZE / 2;
                        const targetPos = this.getGemPosition(row, col);

                        this.board[row][col] = gemType;
                        const gem = this.createGem(row, col, gemType, startY);
                        this.gems[row][col] = gem;

                        const totalDistance = startOffset + row;
                        const duration = (totalDistance * (CELL_SIZE + GAP)) / FALL_SPEED * 1000;
                        maxDistance = Math.max(maxDistance, totalDistance);

                        animations.push(new Promise(resolve => {
                            this.tweens.add({
                                targets: gem,
                                y: targetPos.y,
                                duration: duration,
                                ease: 'Linear',
                                onComplete: resolve
                            });
                        }));
                    }
                }

                await Promise.all(animations);
            }

            showMessage(text) {
                this.messageText.setText(text);
                this.messageText.setAlpha(1);

                this.tweens.add({
                    targets: this.messageText,
                    alpha: 0,
                    delay: 1500,
                    duration: 500
                });
            }

            restartGame() {
                // Destroy all gems
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (this.gems[row] && this.gems[row][col]) {
                            this.gems[row][col].destroy();
                        }
                    }
                }

                // Reset state
                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.selectedGem = null;
                this.isProcessing = false;

                this.scoreText.setText('0');
                this.movesText.setText('0');
                this.comboText.setText('x1');

                this.selectionIndicator.setVisible(false);
                this.tweens.killTweensOf(this.selectionIndicator);
                this.selectionIndicator.setScale(1);

                // Create new board
                this.createBoard();
                this.removeInitialMatches();

                this.showMessage('–ù–æ–≤–∞—è –∏–≥—Ä–∞!');
            }
        }

        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 100,
            height: BOARD_SIZE * (CELL_SIZE + GAP) - GAP + 220,
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scene: MainScene,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        // Start game
        const game = new Phaser.Game(config);
    </script>
</body>
</html>
