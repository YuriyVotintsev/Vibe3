<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match-3 Game - Phaser</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <script>
        // Auto-fetch build info from GitHub API
        let BUILD_ID = 'loading...';
        fetch('https://api.github.com/repos/YuriyVotintsev/Vibe3/commits/claude/match3-game-2pLam')
            .then(r => r.json())
            .then(data => {
                BUILD_ID = data.sha?.substring(0, 7) || 'unknown';
                // Update in any active scene
                if (window.game?.scene?.scenes) {
                    window.game.scene.scenes.forEach(s => {
                        if (s.buildText) s.buildText.setText(`build: ${BUILD_ID}`);
                    });
                }
            })
            .catch(() => { BUILD_ID = 'offline'; });

        // All available gem colors (20 total)
        const ALL_GEM_COLORS = [
            0xe74c3c, // 1. red
            0x3498db, // 2. blue
            0x27ae60, // 3. green
            0xf1c40f, // 4. yellow
            0x9b59b6, // 5. purple
            0xe67e22, // 6. orange
            0x1abc9c, // 7. turquoise
            0xe91e63, // 8. pink
            0x00bcd4, // 9. cyan
            0x8bc34a, // 10. lime
            0xff5722, // 11. deep orange
            0x607d8b, // 12. blue grey
            0x795548, // 13. brown
            0x9c27b0, // 14. deep purple
            0x3f51b5, // 15. indigo
            0x009688, // 16. teal
            0xcddc39, // 17. yellow-green
            0xffc107, // 18. amber
            0x03a9f4, // 19. light blue
            0xf44336  // 20. bright red
        ];

        // Game settings (mutable)
        const GameSettings = {
            boardSize: 8,
            colorCount: 6,
            fallSpeed: 500,
            gap: 4,
            spawnDelay: 80
        };

        // Constants
        const BOARD_TOTAL_SIZE = 500; // Fixed total board size in pixels
        const BOARD_OFFSET_X = 50;
        const BOARD_OFFSET_Y = 120;
        const SWAP_DURATION = 150;

        // Calculate cell size based on board size
        function getCellSize() {
            const totalGaps = (GameSettings.boardSize - 1) * GameSettings.gap;
            return (BOARD_TOTAL_SIZE - totalGaps) / GameSettings.boardSize;
        }

        // Gem states
        const GEM_STATE = {
            IDLE: 'idle',
            FALLING: 'falling',
            SWAPPING: 'swapping',
            MATCHED: 'matched'
        };

        // ==================== SETTINGS SCENE ====================
        class SettingsScene extends Phaser.Scene {
            constructor() {
                super({ key: 'SettingsScene' });
            }

            create() {
                const cx = this.cameras.main.width / 2;
                const cy = this.cameras.main.height / 2;

                // Darken background
                this.add.rectangle(cx, cy, this.cameras.main.width, this.cameras.main.height, 0x000000, 0.85);

                // Title
                this.add.text(cx, 50, '‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏', { fontSize: '28px', color: '#e94560' }).setOrigin(0.5);

                let yPos = 130;
                const spacing = 80;

                // Board size
                this.createSlider('–†–∞–∑–º–µ—Ä –ø–æ–ª—è', yPos, 4, 12, GameSettings.boardSize, val => {
                    GameSettings.boardSize = val;
                });
                yPos += spacing;

                // Color count
                this.createSlider('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–≤–µ—Ç–æ–≤', yPos, 3, 20, GameSettings.colorCount, val => {
                    GameSettings.colorCount = val;
                });
                yPos += spacing;

                // Fall speed
                this.createSlider('–°–∫–æ—Ä–æ—Å—Ç—å –ø–∞–¥–µ–Ω–∏—è', yPos, 50, 1000, GameSettings.fallSpeed, val => {
                    GameSettings.fallSpeed = val;
                }, 50);
                yPos += spacing + 30;

                // Apply button
                const applyBtn = this.add.rectangle(cx, yPos, 200, 50, 0x27ae60)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => applyBtn.setFillStyle(0x2ecc71))
                    .on('pointerout', () => applyBtn.setFillStyle(0x27ae60))
                    .on('pointerdown', () => this.applySettings());

                this.add.text(cx, yPos, '‚úì –ü—Ä–∏–º–µ–Ω–∏—Ç—å', { fontSize: '18px', color: '#ffffff' }).setOrigin(0.5);

                // Cancel button
                const cancelBtn = this.add.rectangle(cx, yPos + 60, 200, 50, 0xe74c3c)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => cancelBtn.setFillStyle(0xc0392b))
                    .on('pointerout', () => cancelBtn.setFillStyle(0xe74c3c))
                    .on('pointerdown', () => this.scene.stop());

                this.add.text(cx, yPos + 60, '‚úï –û—Ç–º–µ–Ω–∞', { fontSize: '18px', color: '#ffffff' }).setOrigin(0.5);
            }

            createSlider(label, y, min, max, currentValue, onChange, step = 1) {
                const cx = this.cameras.main.width / 2;
                const barWidth = 100;

                this.add.text(cx, y, label, { fontSize: '16px', color: '#aaaaaa' }).setOrigin(0.5);

                // Value display
                const valueText = this.add.text(cx + 130, y + 30, currentValue.toString(), {
                    fontSize: '20px', color: '#e94560', fontStyle: 'bold'
                }).setOrigin(0.5);

                // Progress bar background
                this.add.rectangle(cx - 20, y + 30, barWidth, 8, 0x333333);

                // Progress bar fill (dynamic)
                const progressBar = this.add.rectangle(cx - 20, y + 30, barWidth, 8, 0xe94560);
                progressBar.setOrigin(0.5);

                const updateBar = (val) => {
                    const progress = (val - min) / (max - min);
                    progressBar.setScale(progress, 1);
                };
                updateBar(currentValue);

                // Minus button
                const minusBtn = this.add.rectangle(cx - 120, y + 30, 40, 40, 0x444444)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => minusBtn.setFillStyle(0x555555))
                    .on('pointerout', () => minusBtn.setFillStyle(0x444444))
                    .on('pointerdown', () => {
                        let val = parseInt(valueText.text) - step;
                        if (val >= min) {
                            valueText.setText(val.toString());
                            onChange(val);
                            updateBar(val);
                        }
                    });
                this.add.text(cx - 120, y + 30, '‚àí', { fontSize: '24px', color: '#ffffff' }).setOrigin(0.5);

                // Plus button
                const plusBtn = this.add.rectangle(cx + 80, y + 30, 40, 40, 0x444444)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => plusBtn.setFillStyle(0x555555))
                    .on('pointerout', () => plusBtn.setFillStyle(0x444444))
                    .on('pointerdown', () => {
                        let val = parseInt(valueText.text) + step;
                        if (val <= max) {
                            valueText.setText(val.toString());
                            onChange(val);
                            updateBar(val);
                        }
                    });
                this.add.text(cx + 80, y + 30, '+', { fontSize: '24px', color: '#ffffff' }).setOrigin(0.5);
            }

            applySettings() {
                this.scene.stop();
                // Full scene restart to recreate everything
                this.scene.stop('MainScene');
                this.scene.start('MainScene');
            }
        }

        // ==================== MAIN SCENE ====================
        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
            }

            init() {
                this.board = [];
                this.gems = [];
                this.selectedGem = null;
                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.lastSpawnTime = {};
                this.pendingMatches = [];
            }

            preload() {
                this.createGemTextures();
            }

            createGemTextures() {
                const cellSize = getCellSize();
                const size = cellSize - 8;
                const radius = 10;

                // Create textures for all possible colors
                for (let i = 0; i < ALL_GEM_COLORS.length; i++) {
                    const key = `gem_${i}`;
                    if (this.textures.exists(key)) {
                        this.textures.remove(key);
                    }

                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                    graphics.fillStyle(ALL_GEM_COLORS[i], 1);
                    graphics.fillRoundedRect(0, 0, size, size, radius);
                    graphics.fillStyle(0xffffff, 0.3);
                    graphics.fillRoundedRect(4, 4, size - 20, size - 20, radius - 2);
                    graphics.fillStyle(0x000000, 0.2);
                    graphics.fillRoundedRect(8, size - 16, size - 16, 8, 4);
                    graphics.generateTexture(key, size, size);
                    graphics.destroy();
                }

                if (this.textures.exists('selection')) {
                    this.textures.remove('selection');
                }
                const selectGraphics = this.make.graphics({ x: 0, y: 0, add: false });
                selectGraphics.lineStyle(4, 0xffffff, 1);
                selectGraphics.strokeRoundedRect(2, 2, cellSize - 4, cellSize - 4, 12);
                selectGraphics.generateTexture('selection', cellSize, cellSize);
                selectGraphics.destroy();
            }

            create() {
                const boardSize = GameSettings.boardSize;
                const cellSize = getCellSize();
                const gap = GameSettings.gap;

                // Background
                this.add.rectangle(
                    this.cameras.main.width / 2,
                    this.cameras.main.height / 2,
                    this.cameras.main.width,
                    this.cameras.main.height,
                    0x1a1a2e
                );

                // Board background (fixed size)
                const boardBgSize = BOARD_TOTAL_SIZE + 20;
                this.add.rectangle(
                    BOARD_OFFSET_X + BOARD_TOTAL_SIZE / 2,
                    BOARD_OFFSET_Y + BOARD_TOTAL_SIZE / 2,
                    boardBgSize,
                    boardBgSize,
                    0x000000,
                    0.3
                ).setStrokeStyle(2, 0x333333);

                this.createUI();
                this.createBoard();

                this.selectionIndicator = this.add.image(0, 0, 'selection');
                this.selectionIndicator.setVisible(false);
                this.selectionIndicator.setDepth(100);

                this.removeInitialMatches();

                this.input.on('gameobjectdown', this.onGemClick, this);

                for (let col = 0; col < boardSize; col++) {
                    this.lastSpawnTime[col] = 0;
                }

                // Clean up on shutdown
                this.events.on('shutdown', this.shutdown, this);
            }

            shutdown() {
                this.input.off('gameobjectdown', this.onGemClick, this);
            }

            createUI() {
                this.add.text(
                    this.cameras.main.width / 2, 30,
                    'üéÆ Match-3',
                    { fontSize: '32px', fontFamily: 'Segoe UI', color: '#e94560' }
                ).setOrigin(0.5);

                const panelY = 75;
                const panelSpacing = 150;
                const startX = this.cameras.main.width / 2 - panelSpacing;

                this.add.text(startX, panelY, '–û–ß–ö–ò', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.scoreText = this.add.text(startX, panelY + 22, '0', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                this.add.text(startX + panelSpacing, panelY, '–•–û–î–´', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.movesText = this.add.text(startX + panelSpacing, panelY + 22, '0', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                this.add.text(startX + panelSpacing * 2, panelY, '–ö–û–ú–ë–û', { fontSize: '14px', color: '#aaaaaa' }).setOrigin(0.5);
                this.comboText = this.add.text(startX + panelSpacing * 2, panelY + 22, 'x1', { fontSize: '24px', color: '#e94560', fontStyle: 'bold' }).setOrigin(0.5);

                this.messageText = this.add.text(
                    this.cameras.main.width / 2,
                    BOARD_OFFSET_Y + BOARD_TOTAL_SIZE + 30,
                    '',
                    { fontSize: '20px', color: '#55efc4' }
                ).setOrigin(0.5);

                const btnY = BOARD_OFFSET_Y + BOARD_TOTAL_SIZE + 70;

                // New game button
                const newGameBtn = this.add.rectangle(this.cameras.main.width / 2 - 90, btnY, 150, 45, 0xe94560)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => newGameBtn.setFillStyle(0xc0392b))
                    .on('pointerout', () => newGameBtn.setFillStyle(0xe94560))
                    .on('pointerdown', () => this.restartGame());
                this.add.text(this.cameras.main.width / 2 - 90, btnY, 'üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞', { fontSize: '14px', color: '#ffffff' }).setOrigin(0.5);

                // Settings button
                const settingsBtn = this.add.rectangle(this.cameras.main.width / 2 + 90, btnY, 150, 45, 0x3498db)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => settingsBtn.setFillStyle(0x2980b9))
                    .on('pointerout', () => settingsBtn.setFillStyle(0x3498db))
                    .on('pointerdown', () => this.scene.launch('SettingsScene'));
                this.add.text(this.cameras.main.width / 2 + 90, btnY, '‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏', { fontSize: '14px', color: '#ffffff' }).setOrigin(0.5);

                // Build ID display
                this.buildText = this.add.text(
                    this.cameras.main.width - 10,
                    this.cameras.main.height - 10,
                    `build: ${BUILD_ID}`,
                    { fontSize: '14px', color: '#888888' }
                ).setOrigin(1, 1);
            }

            createBoard() {
                this.board = [];
                this.gems = [];
                const boardSize = GameSettings.boardSize;

                for (let row = 0; row < boardSize; row++) {
                    this.board[row] = [];
                    this.gems[row] = [];
                    for (let col = 0; col < boardSize; col++) {
                        const gemType = Phaser.Math.Between(0, GameSettings.colorCount - 1);
                        this.board[row][col] = gemType;
                        this.gems[row][col] = this.createGem(row, col, gemType);
                    }
                }
            }

            createGem(row, col, gemType, startY = null) {
                const pos = this.getGemPosition(row, col);
                const gem = this.add.image(pos.x, startY !== null ? startY : pos.y, `gem_${gemType}`);
                gem.setInteractive({ useHandCursor: true });
                gem.setData('row', row);
                gem.setData('col', col);
                gem.setData('type', gemType);
                gem.setData('state', GEM_STATE.IDLE);
                gem.setData('targetY', pos.y);
                return gem;
            }

            getGemPosition(row, col) {
                const cellSize = getCellSize();
                const gap = GameSettings.gap;
                return {
                    x: BOARD_OFFSET_X + col * (cellSize + gap) + cellSize / 2,
                    y: BOARD_OFFSET_Y + row * (cellSize + gap) + cellSize / 2
                };
            }

            removeInitialMatches() {
                let hasMatches = true;
                while (hasMatches) {
                    const matches = this.findAllMatches();
                    if (matches.length === 0) {
                        hasMatches = false;
                    } else {
                        matches.forEach(({ row, col }) => {
                            const newType = Phaser.Math.Between(0, GameSettings.colorCount - 1);
                            this.board[row][col] = newType;
                            this.gems[row][col].setTexture(`gem_${newType}`);
                            this.gems[row][col].setData('type', newType);
                        });
                    }
                }
            }

            update(time, delta) {
                this.updateFallingGems(delta);
                this.updateGravity();
                this.spawnNewGems(time);
                this.checkLandedGems();
            }

            updateFallingGems(delta) {
                const fallAmount = (GameSettings.fallSpeed * delta) / 1000;
                const boardSize = GameSettings.boardSize;

                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const gem = this.gems[row]?.[col];
                        if (!gem) continue;

                        if (gem.getData('state') === GEM_STATE.FALLING) {
                            const targetY = gem.getData('targetY');

                            if (gem.y < targetY) {
                                gem.y = Math.min(gem.y + fallAmount, targetY);

                                if (gem.y >= targetY) {
                                    gem.y = targetY;
                                    gem.setData('state', GEM_STATE.IDLE);
                                    this.pendingMatches.push({ row, col });
                                }
                            }
                        }
                    }
                }
            }

            updateGravity() {
                const boardSize = GameSettings.boardSize;

                for (let col = 0; col < boardSize; col++) {
                    for (let row = boardSize - 1; row >= 0; row--) {
                        if (this.board[row][col] === null) {
                            for (let aboveRow = row - 1; aboveRow >= 0; aboveRow--) {
                                if (this.board[aboveRow][col] !== null) {
                                    const gem = this.gems[aboveRow][col];
                                    if (gem && gem.getData('state') === GEM_STATE.IDLE) {
                                        this.board[row][col] = this.board[aboveRow][col];
                                        this.board[aboveRow][col] = null;

                                        this.gems[row][col] = gem;
                                        this.gems[aboveRow][col] = null;

                                        gem.setData('row', row);
                                        gem.setData('targetY', this.getGemPosition(row, col).y);
                                        gem.setData('state', GEM_STATE.FALLING);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            spawnNewGems(time) {
                const boardSize = GameSettings.boardSize;
                const cellSize = getCellSize();
                const gap = GameSettings.gap;

                for (let col = 0; col < boardSize; col++) {
                    if (this.board[0][col] === null) {
                        if (time - this.lastSpawnTime[col] >= GameSettings.spawnDelay) {
                            let canSpawn = true;
                            for (let r = 0; r < boardSize; r++) {
                                const gem = this.gems[r]?.[col];
                                if (gem && gem.getData('state') === GEM_STATE.FALLING) {
                                    const targetRow = gem.getData('row');
                                    if (targetRow <= 0) {
                                        canSpawn = false;
                                        break;
                                    }
                                }
                            }

                            if (canSpawn) {
                                const gemType = Phaser.Math.Between(0, GameSettings.colorCount - 1);
                                const startY = BOARD_OFFSET_Y - cellSize / 2 - gap;
                                const gem = this.createGem(0, col, gemType, startY);

                                this.board[0][col] = gemType;
                                this.gems[0][col] = gem;
                                gem.setData('state', GEM_STATE.FALLING);

                                this.lastSpawnTime[col] = time;
                            }
                        }
                    }
                }
            }

            checkLandedGems() {
                if (this.pendingMatches.length === 0) return;

                const toCheck = [...this.pendingMatches];
                this.pendingMatches = [];

                const matches = this.findAllMatches();

                if (matches.length > 0) {
                    const points = matches.length * 10 * this.combo;
                    this.score += points;
                    this.scoreText.setText(this.score.toString());

                    if (matches.length > 3) {
                        this.showMessage(`+${points}`);
                    }

                    matches.forEach(({ row, col }) => {
                        const gem = this.gems[row]?.[col];
                        if (gem && gem.getData('state') !== GEM_STATE.MATCHED) {
                            gem.setData('state', GEM_STATE.MATCHED);

                            this.tweens.add({
                                targets: gem,
                                scale: 0,
                                alpha: 0,
                                duration: 150,
                                ease: 'Power2',
                                onComplete: () => {
                                    gem.destroy();
                                }
                            });

                            this.board[row][col] = null;
                            this.gems[row][col] = null;
                        }
                    });

                    this.combo++;
                    this.comboText.setText(`x${this.combo}`);
                }
            }

            onGemClick(pointer, gem) {
                if (gem.getData('state') !== GEM_STATE.IDLE) return;

                const row = gem.getData('row');
                const col = gem.getData('col');

                if (this.selectedGem === null) {
                    this.selectedGem = { row, col, gem };
                    const pos = this.getGemPosition(row, col);
                    this.selectionIndicator.setPosition(pos.x, pos.y);
                    this.selectionIndicator.setVisible(true);

                    this.tweens.killTweensOf(this.selectionIndicator);
                    this.tweens.add({
                        targets: this.selectionIndicator,
                        scale: { from: 1, to: 1.1 },
                        duration: 300,
                        yoyo: true,
                        repeat: -1
                    });
                } else {
                    const { row: prevRow, col: prevCol, gem: prevGem } = this.selectedGem;

                    if (!prevGem || prevGem.getData('state') !== GEM_STATE.IDLE) {
                        this.clearSelection();
                        return;
                    }

                    if (this.areAdjacent(prevRow, prevCol, row, col)) {
                        this.clearSelection();
                        this.swapGems(prevRow, prevCol, row, col);
                    } else {
                        this.selectedGem = { row, col, gem };
                        const pos = this.getGemPosition(row, col);
                        this.selectionIndicator.setPosition(pos.x, pos.y);
                    }
                }
            }

            clearSelection() {
                this.selectedGem = null;
                this.selectionIndicator.setVisible(false);
                this.tweens.killTweensOf(this.selectionIndicator);
                this.selectionIndicator.setScale(1);
            }

            areAdjacent(row1, col1, row2, col2) {
                const rowDiff = Math.abs(row1 - row2);
                const colDiff = Math.abs(col1 - col2);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            swapGems(row1, col1, row2, col2) {
                const gem1 = this.gems[row1][col1];
                const gem2 = this.gems[row2][col2];

                if (!gem1 || !gem2) return;
                if (gem1.getData('state') !== GEM_STATE.IDLE) return;
                if (gem2.getData('state') !== GEM_STATE.IDLE) return;

                gem1.setData('state', GEM_STATE.SWAPPING);
                gem2.setData('state', GEM_STATE.SWAPPING);

                const pos1 = this.getGemPosition(row1, col1);
                const pos2 = this.getGemPosition(row2, col2);

                [this.board[row1][col1], this.board[row2][col2]] = [this.board[row2][col2], this.board[row1][col1]];
                [this.gems[row1][col1], this.gems[row2][col2]] = [this.gems[row2][col2], this.gems[row1][col1]];

                gem1.setData('row', row2);
                gem1.setData('col', col2);
                gem2.setData('row', row1);
                gem2.setData('col', col1);

                this.tweens.add({
                    targets: gem1,
                    x: pos2.x,
                    y: pos2.y,
                    duration: SWAP_DURATION,
                    ease: 'Power2'
                });

                this.tweens.add({
                    targets: gem2,
                    x: pos1.x,
                    y: pos1.y,
                    duration: SWAP_DURATION,
                    ease: 'Power2',
                    onComplete: () => {
                        gem1.setData('state', GEM_STATE.IDLE);
                        gem2.setData('state', GEM_STATE.IDLE);
                        gem1.setData('targetY', pos2.y);
                        gem2.setData('targetY', pos1.y);

                        const matches = this.findAllMatches();

                        if (matches.length > 0) {
                            this.moves++;
                            this.movesText.setText(this.moves.toString());
                            this.combo = 1;

                            this.pendingMatches.push({ row: row2, col: col2 });
                            this.pendingMatches.push({ row: row1, col: col1 });
                        } else {
                            gem1.setData('state', GEM_STATE.SWAPPING);
                            gem2.setData('state', GEM_STATE.SWAPPING);

                            [this.board[row1][col1], this.board[row2][col2]] = [this.board[row2][col2], this.board[row1][col1]];
                            [this.gems[row1][col1], this.gems[row2][col2]] = [this.gems[row2][col2], this.gems[row1][col1]];

                            gem1.setData('row', row1);
                            gem1.setData('col', col1);
                            gem2.setData('row', row2);
                            gem2.setData('col', col2);

                            this.tweens.add({
                                targets: gem1,
                                x: pos1.x,
                                y: pos1.y,
                                duration: SWAP_DURATION,
                                ease: 'Power2'
                            });

                            this.tweens.add({
                                targets: gem2,
                                x: pos2.x,
                                y: pos2.y,
                                duration: SWAP_DURATION,
                                ease: 'Power2',
                                onComplete: () => {
                                    gem1.setData('state', GEM_STATE.IDLE);
                                    gem2.setData('state', GEM_STATE.IDLE);
                                    gem1.setData('targetY', pos1.y);
                                    gem2.setData('targetY', pos2.y);
                                }
                            });

                            this.showMessage('–ù–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π!');
                        }
                    }
                });
            }

            findAllMatches() {
                const matches = new Set();
                const boardSize = GameSettings.boardSize;

                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize - 2; col++) {
                        const type = this.board[row]?.[col];
                        if (type !== null && type !== undefined &&
                            type === this.board[row]?.[col + 1] &&
                            type === this.board[row]?.[col + 2]) {
                            const g1 = this.gems[row]?.[col];
                            const g2 = this.gems[row]?.[col + 1];
                            const g3 = this.gems[row]?.[col + 2];
                            if (g1?.getData('state') === GEM_STATE.IDLE &&
                                g2?.getData('state') === GEM_STATE.IDLE &&
                                g3?.getData('state') === GEM_STATE.IDLE) {
                                matches.add(`${row},${col}`);
                                matches.add(`${row},${col + 1}`);
                                matches.add(`${row},${col + 2}`);

                                let k = col + 3;
                                while (k < boardSize && this.board[row]?.[k] === type) {
                                    const gk = this.gems[row]?.[k];
                                    if (gk?.getData('state') === GEM_STATE.IDLE) {
                                        matches.add(`${row},${k}`);
                                    }
                                    k++;
                                }
                            }
                        }
                    }
                }

                for (let col = 0; col < boardSize; col++) {
                    for (let row = 0; row < boardSize - 2; row++) {
                        const type = this.board[row]?.[col];
                        if (type !== null && type !== undefined &&
                            type === this.board[row + 1]?.[col] &&
                            type === this.board[row + 2]?.[col]) {
                            const g1 = this.gems[row]?.[col];
                            const g2 = this.gems[row + 1]?.[col];
                            const g3 = this.gems[row + 2]?.[col];
                            if (g1?.getData('state') === GEM_STATE.IDLE &&
                                g2?.getData('state') === GEM_STATE.IDLE &&
                                g3?.getData('state') === GEM_STATE.IDLE) {
                                matches.add(`${row},${col}`);
                                matches.add(`${row + 1},${col}`);
                                matches.add(`${row + 2},${col}`);

                                let k = row + 3;
                                while (k < boardSize && this.board[k]?.[col] === type) {
                                    const gk = this.gems[k]?.[col];
                                    if (gk?.getData('state') === GEM_STATE.IDLE) {
                                        matches.add(`${k},${col}`);
                                    }
                                    k++;
                                }
                            }
                        }
                    }
                }

                return Array.from(matches).map(pos => {
                    const [row, col] = pos.split(',').map(Number);
                    return { row, col };
                });
            }

            showMessage(text) {
                this.messageText.setText(text);
                this.messageText.setAlpha(1);

                this.tweens.add({
                    targets: this.messageText,
                    alpha: 0,
                    delay: 1000,
                    duration: 500
                });
            }

            restartGame() {
                const boardSize = GameSettings.boardSize;

                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        if (this.gems[row]?.[col]) {
                            this.gems[row][col].destroy();
                        }
                    }
                }

                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.selectedGem = null;
                this.pendingMatches = [];

                this.scoreText.setText('0');
                this.movesText.setText('0');
                this.comboText.setText('x1');

                this.clearSelection();

                for (let col = 0; col < boardSize; col++) {
                    this.lastSpawnTime[col] = 0;
                }

                this.createBoard();
                this.removeInitialMatches();

                this.showMessage('–ù–æ–≤–∞—è –∏–≥—Ä–∞!');
            }
        }

        // Fixed dimensions based on total board size
        const config = {
            type: Phaser.AUTO,
            width: BOARD_TOTAL_SIZE + 100,
            height: BOARD_TOTAL_SIZE + 220,
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scene: [MainScene, SettingsScene],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
